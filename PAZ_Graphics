#ifndef PAZ_GRAPHICS
#define PAZ_GRAPHICS

#include <PAZ_IO>
#include <iostream>
#include <vector>
#include <array>
#include <functional>
#include <unordered_map>
#include <chrono>
#include <unordered_set>
#include <memory>

namespace paz
{
    template<typename T>
    using require_iterable = std::enable_if_t<std::is_same<decltype(std::begin(
        std::declval<const T&>())), decltype(std::end(std::declval<const
        T&>()))>::value>;

    class Texture
    {
        friend class Framebuffer;
        friend class RenderPass;

        Texture(const Texture&) = delete;
        Texture& operator=(const Texture&) = delete;

    public:
        enum class Format
        {
            R8UInt, R8SInt, R8UNorm, R8SNorm, R16UInt, R16SInt, R16UNorm,
            R16SNorm, R16Float, R32UInt, R32SInt, R32Float, RG8UInt, RG8SInt,
            RG8UNorm, RG8SNorm, RG16UInt, RG16SInt, RG16UNorm, RG16SNorm,
            RG16Float, RG32UInt, RG32SInt, RG32Float, RGBA8UInt, RGBA8SInt,
            RGBA8UNorm, RGBA8SNorm, RGBA16UInt, RGBA16SInt, RGBA16UNorm,
            RGBA16SNorm, RGBA16Float, RGBA32UInt, RGBA32SInt, RGBA32Float,
            Depth16UNorm, Depth32Float
        };

        enum class MinMagFilter
        {
            Linear, Nearest
        };

        enum class MipmapFilter
        {
            Linear, Nearest, None
        };

    protected:
        struct Data;
        std::unique_ptr<Data> _data;

        Texture();
        void init(const void* data = nullptr);

    public:
        virtual ~Texture();
        Texture(int width, int height, Format format, MinMagFilter minFilter,
            MinMagFilter magFilter);
        Texture(const Image<std::uint8_t, 1>& image, MinMagFilter
            minFilter, MinMagFilter magFilter, bool normalized = true);
        // ...
        void resize(int width, int height);
        int width() const;
        int height() const;
    };

    class RenderTarget : public Texture
    {
        RenderTarget(const RenderTarget&) = delete;
        RenderTarget& operator=(const RenderTarget&) = delete;

    public:
        ~RenderTarget();
        RenderTarget(double scale, Format format, MinMagFilter minFilter,
            MinMagFilter magFilter);
        RenderTarget(int width, int height, Format format, MinMagFilter
            minFilter, MinMagFilter magFilter);
    };

    class VertexBuffer
    {
        friend class RenderPass;

        struct Data;
        std::unique_ptr<Data> _data;

        VertexBuffer(const VertexBuffer&) = delete;
        VertexBuffer& operator=(const VertexBuffer&) = delete;

    public:
        ~VertexBuffer();
        VertexBuffer();
        void attribute(int dim, const float* data, std::size_t size);
        void attribute(int dim, const unsigned int* data, std::size_t size);
        void attribute(int dim, const int* data, std::size_t size);
        template<typename T, require_iterable<T>* = nullptr>
        void attribute(int dim, const T& data)
        {
            attribute(dim, &*std::begin(data), std::distance(&*std::begin(data),
                &*std::end(data)));
        }
    };

    class IndexBuffer
    {
        friend class RenderPass;

        struct Data;
        std::unique_ptr<Data> _data;

        IndexBuffer(const IndexBuffer&) = delete;
        IndexBuffer& operator=(const IndexBuffer&) = delete;

    public:
        ~IndexBuffer();
        IndexBuffer(const unsigned int* data, std::size_t size);
        IndexBuffer(const std::vector<unsigned int>& data) : IndexBuffer(data.
            data(), data.size()) {}
        template<typename T, require_iterable<T>* = nullptr>
        IndexBuffer(const T& data) : IndexBuffer(&*std::begin(data), std::
            distance(&*std::begin(data), &*std::end(data))) {}
    };

    class Framebuffer
    {
        friend class RenderPass;

        struct Data;
        std::unique_ptr<Data> _data;

        Framebuffer(const Framebuffer&) = delete;
        Framebuffer& operator=(const Framebuffer&) = delete;

    public:
        ~Framebuffer();
        Framebuffer();
        void attach(const RenderTarget& target);
    };

    class ShaderFunctionLibrary
    {
        friend class Shader;

        struct Data;
        std::unique_ptr<Data> _data;

        ShaderFunctionLibrary(const ShaderFunctionLibrary&) = delete;
        ShaderFunctionLibrary& operator=(const ShaderFunctionLibrary&) = delete;

    public:
        ShaderFunctionLibrary();
        ~ShaderFunctionLibrary();
        void vertex(const std::string& name, const std::string& src);
        void geometry(const std::string& name, const std::string& src);
        void fragment(const std::string& name, const std::string& src);
    };

    class Shader
    {
        friend class RenderPass;

        struct Data;
        std::unique_ptr<Data> _data;

        Shader(const Shader&) = delete;
        Shader& operator=(const Shader&) = delete;

    public:
        ~Shader();
        Shader(const ShaderFunctionLibrary& vertLibrary, const std::string&
            vertName, const ShaderFunctionLibrary& fragLibrary, const std::
            string& fragName);
        Shader(const ShaderFunctionLibrary& vertLibrary, const std::string&
            vertName, const ShaderFunctionLibrary& geomLibrary, const std::
            string& geomName, const ShaderFunctionLibrary& fragLibrary, const
            std::string& fragName);
    };

    class RenderPass
    {
    public:
        enum class DepthTestMode
        {
            NeverNoMask, LessNoMask, EqualNoMask, LessEqualNoMask,
            GreaterNoMask, NotEqualNoMask, GreaterEqualNoMask, AlwaysNoMask,
            Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual,
            Always, Disable
        };

        enum class BlendMode
        {
            Additive, Blend, Disable
        };

        enum class LoadAction
        {
            Clear, Load, DontCare
        };

        enum class CullMode
        {
            Front, Back, Disable
        };

    private:
        struct Data;
        std::unique_ptr<Data> _data;

        RenderPass(const RenderPass&) = delete;
        RenderPass& operator=(const RenderPass&) = delete;

    public:
        enum class PrimitiveType
        {
            Points, Lines, LineStrip, Triangles, TriangleStrip
        };

        ~RenderPass();
        RenderPass(const Framebuffer& fbo, const Shader& shader, BlendMode mode
            = BlendMode::Disable);
        RenderPass(const Shader& shader, BlendMode mode = BlendMode::Disable);
        void begin(const std::vector<LoadAction>& colorLoadActions = {},
            LoadAction depthLoadAction = LoadAction::DontCare);
        void end();
        void depth(DepthTestMode depthMode);
        void cull(CullMode mode) const;
        void read(const std::string& name, const Texture& tex) const;
        void uniform(const std::string& name, int x) const;
        void uniform(const std::string& name, int x, int y) const;
        void uniform(const std::string& name, int x, int y, int z) const;
        void uniform(const std::string& name, int x, int y, int z, int w) const;
        void uniform(const std::string& name, const int* x, std::size_t size)
            const;
        void uniform(const std::string& name, unsigned int x) const;
        void uniform(const std::string& name, unsigned int x, unsigned int y)
            const;
        void uniform(const std::string& name, unsigned int x, unsigned int y,
            unsigned int z) const;
        void uniform(const std::string& name, unsigned int x, unsigned int y,
            unsigned int z, unsigned int w) const;
        void uniform(const std::string& name, const unsigned int* x, std::size_t
            size) const;
        void uniform(const std::string& name, float x) const;
        void uniform(const std::string& name, float x, float y) const;
        void uniform(const std::string& name, float x, float y, float z) const;
        void uniform(const std::string& name, float x, float y, float z, float
            w) const;
        void uniform(const std::string& name, const float* x, std::size_t size)
            const;
        template<typename T, require_iterable<T>* = nullptr>
        void uniform(const std::string& name, const T& data)
        {
            uniform(name, &*std::begin(data), std::distance(&*std::begin(data),
                &*std::end(data)));
        }
        void primitives(PrimitiveType type, const VertexBuffer& vertices, int
            offset = 0) const;
        void indexed(PrimitiveType type, const VertexBuffer& vertices, const
            IndexBuffer& indices, int offset = 0) const;
    };

    std::array<float, 16> perspective(float yFov, float ratio, float zNear,
        float zFar);
    std::array<float, 16> ortho(const float left, const float right, const float
        bottom, const float top, const float zNear, const float zFar);
    std::array<float, 16> transform(const std::array<float, 3>& delta, const
        std::array<float, 9>& rot);

    class Window
    {
    public:
        enum class CursorMode
        {
            Normal, Hidden, Disable
        };

        enum class Key : int
        {
            Space, Apostrophe, Comma, Minus, Period, Slash, Zero, One, Two,
            Three, Four, Five, Six, Seven, Eight, Nine, Semicolon, Equal, A, B,
            C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X,
            Y, Z, LeftBracket, Backslash, RightBracket, Grave, Escape, Enter,
            Tab, Backspace, Insert, Delete, Right, Left, Down, Up, PageUp,
            PageDown, Home, End, CapsLock, F1, F2, F3, F4, F5, F6, F7, F8, F9,
            F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22,
            F23, F24, F25, Keypad0, Keypad1, Keypad2, Keypad3, Keypad4, Keypad5,
            Keypad6, Keypad7, Keypad8, Keypad9, KeypadDecimal, KeypadDivide,
            KeypadMultiply, KeypadMinus, KeypadPlus, KeypadEnter, KeypadEqual,
            LeftShift, LeftControl, LeftAlt, LeftSuper, RightShift,
            RightControl, RightAlt, RightSuper, Unknown
        };

        static constexpr int NumKeys = static_cast<int>(Key::Unknown);
        static constexpr int NumMouseButtons = 8;

        Window() = delete;
        static void MakeFullscreen();
        static void MakeWindowed();
        static void SetTitle(const std::string& title);
        static bool IsKeyWindow();
        static bool IsFullscreen();
        static int ViewportWidth();
        static int ViewportHeight();
        static int Width();
        static int Height();
        static bool KeyDown(Key key);
        static bool KeyPressed(Key key);
        static bool KeyReleased(Key key);
        static bool MouseDown(int button);
        static bool MousePressed(int button);
        static bool MouseReleased(int button);
        static std::pair<double, double> MousePos();
        static std::pair<double, double> ScrollOffset();
        static void SetCursorMode(CursorMode mode);
        static float AspectRatio();
        static void Quit();
        static void Loop(const std::function<void(void)>& draw);
        static double FrameTime();
        static void SetMinSize(int width, int height);
        static void SetMaxSize(int width, int height);
        static void Resize(int width, int height);
        static Image<float, 3> PrintScreen();
    };
}

#endif
